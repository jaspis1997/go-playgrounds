package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"playground/graph/model"
	"strconv"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	// panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
	todo := Todos.Set(&model.Todo{
		Text: input.Text,
		User: Users.Values[input.UserID],
	})
	return todo, nil
}

// CreateUsers is the resolver for the createUsers field.
func (r *mutationResolver) CreateUsers(ctx context.Context, input []*model.NewUser) ([]*model.User, error) {
	// panic(fmt.Errorf("not implemented: CreateUsers - createUsers"))
	var users []*model.User
	for _, v := range input {
		user := Users.Set(&model.User{
			Name: v.Name,
		})
		users = append(users, user)
	}
	return users, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context, ids []*string) ([]*model.Todo, error) {
	// panic(fmt.Errorf("not implemented: Todos - todos"))
	todos := func() (todos []*model.Todo) {
		if ids == nil {
			for _, v := range Todos.Values {
				todos = append(todos, v)
			}
			return
		}
		// slices.SortFunc(todos, func(a, b *model.Todo) int {
		// 	return cmp.Compare(strings.ToLower(a.ID), strings.ToLower(b.ID))
		// })
		// slices.SortFunc(ids, func(a, b *string) int {
		// 	return cmp.Compare(strings.ToLower(*a), strings.ToLower(*b))
		// })
		for _, k := range ids {
			todos = append(todos, Todos.Values[*k])
		}
		return todos
	}
	return todos(), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, ids []*string) ([]*model.User, error) {
	// panic(fmt.Errorf("not implemented: Users - users"))
	users := func() (users []*model.User) {
		if ids == nil {
			for _, v := range Users.Values {
				users = append(users, v)
			}
			return
		}
		for _, k := range ids {
			users = append(users, Users.Values[*k])
		}
		return
	}
	return users(), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var (
	Todos *TodoStore = new(TodoStore)
	Users *UserStore = new(UserStore)
)

type TodoStore struct {
	next   int
	Values map[string]*model.Todo
}

func (store *TodoStore) Set(v *model.Todo) *model.Todo {
	if store.Values == nil {
		store.Values = make(map[string]*model.Todo)
	}
	id := strconv.Itoa(store.next)
	store.next++
	store.Values[id] = v
	v.ID = id
	return v
}

type UserStore struct {
	next   int
	Values map[string]*model.User
}

func (store *UserStore) Set(v *model.User) *model.User {
	if store.Values == nil {
		store.Values = make(map[string]*model.User)
	}
	id := strconv.Itoa(store.next)
	store.next++
	store.Values[id] = v
	v.ID = id
	return v
}
func init() {
	user := Users.Set(&model.User{
		Name: "Alice",
	})
	Todos.Set(&model.Todo{
		Text: "Check Report",
		Done: false,
		User: user,
	})
	Todos.Set(&model.Todo{
		Text: "Check Mail",
		Done: false,
		User: user,
	})
}
